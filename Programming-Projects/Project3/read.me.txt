AUTHOR: Kevin Dong
DATE: 3/14/24 (Pi Day!)


|PLATFORM|: 
    ⚬ macOS, VS CODE


|COMPILE DIRECTIONS|:
    ⚬ Use the provided makeFile to compile program
        ⚬ Executable name: run

|RUN PROGRAM DIRECTIONS|:

|BUGS|:


|SOLUTION APPROACH|:


|LOG|:

    3/14/24:
        ⚬ Understand problem statement
        ⚬ Import over the Lexical Analyzer (from project1) and recursive descent parser (from project2).
        ⚬ Support the new BNF grammar in the grammar class 
            ⚬ Make change to recursive descent parser code  
            ⚬ Pseudocode: 
                1. Prompt for block size
                2. Prompt for input file name
                3. Create an ifstream object
                4. Pass it into Grammar class
                    4a. Keep reading from file until end of file
                    4b. Try to match the grammar
                    4c. If it matches a grammar, run the associated method
                            Q: Should I include the command in the grammar class or make it it's own class?


        ⚬ Write the grammar definition
            ⚬ Done!
            ⚬ Test the Lexical Analyzer...
                ⚬ Works! :D
            ⚬ Test Recursive descent works...
                ⚬ Works! :D


        
        ⚬ Can detect when to call free(variableName)
            ⚬ Not what to code for it

    3/16/24: 
        ⚬ Be able to detect alloc()
            ⚬ Can correct detect ID = alloc(NUM_INT) :D
        ⚬ Be able to detect ID = ID
            ⚬ It works!

        ⚬ Each block
            ⚬ size
            ⚬ memory location
            ⚬ reference count
            ⚬ copy another block's data



            free(variableName): return any storage to the freeList (available blocks)

            dump(): 
                * print each currently allocated variable 
                    [address][allocSize][associated block's reference count]
                * print each block in the freeList 
                    [start location][blockSize]
                        * reference count of 0
                
            compress():
                * join adjacent blocks in the freeList 
                    * appropriate location 
                    * ...sized larger block
                    * leave unadjacent block alone

            alloc(integerAmount):
                * use first fit on freeList

            = otherVariable 
                * take the reference found with the associated with otherVariable
                and also associate it with variableName


            Side note:
                * freeList must be sorted in ascending address free block 
                    * DO NOT COMPRESS UNLESS CALLED BY USER

    3/19/24:
        ⚬ Trying to understand and produce the output

    3/20/24:
        ⚬ Creating a Block class
            ⚬ Done
        ⚬ Creating a Variable class
            ⚬ Done
        ⚬ Editing makeFile
            ⚬ Done
        ⚬ Testing both classes in main 

        ⚬ Can sort freeList by start address

        ⚬ Block class appears to be functioning correctly

        Algorithm: 
            ⚬ ask for init size
                ⚬ starting index = 0 
            ⚬ if id = alloc()
                ⚬ check if this variable has not been allocated yet in our variable list
                ⚬ if variable exists
                    ⚬ => call free();
                        

                ⚬ first fit in freeList
                ⚬ if match and left over
                    ⚬ create left over Free block 
                        ⚬ size = original size - alloc amount
                        ⚬ end index  = same as before (if any left)
                        ⚬ start index = end index - (size - 1)

                        ⚬ add this left over to the freeList
                ⚬ if match but no left over
                    ⚬ remove this "free" block from the list since it is an exact fit
                    ⚬ create variable that points to this block
                    
                    ⚬ create usedBlock
                        ⚬ size = alloc amount 
                        ⚬ start index = parent start index 

                    ⚬ create variable object that points to that usedBlock 

        ⚬ going to execute code while parsing
            ⚬ created a Command class 


    3/21/24:
        ⚬ working on free()
        ⚬ working on equal()

        yay seg fault! :D

        ⚬ plan
            ⚬ try to locate both variables in the varList
            ⚬ [case1]: rhs does NOT exists
                ⚬ cannot perform such an option regardless if LHS exists or not!!
            ⚬ [case2]: RHS  exists
                ⚬ find RHS
                ⚬ create a new variable object regardless if LHS exists or not
                    ⚬ free(old LHS);
                    ⚬ push new LHS to var list
                    ⚬ sort var list
                    ⚬ (should also be able to handle the "lhs = lhs" case)

    3/22/24:
        ⚬ equal() works!
        ⚬ coding compress()
            plan:   
                ⚬ Loop through the freeList
                ⚬ Since sorted in ascending order, we traverse through each node (freeBlock) in the list
                ⚬ Compress two blocks if
                    startIndexBlock1 + Block1Size = startIndexBlock2
                        if true: adjacent!

                            Block1Size = Block1Size + Block2Size
                            startIndexBlock1 remains the same, but endIndex will change

                            remove the Block2 (since it has been compressed)
                            * could delete the memory leak here 

            2 pointer APPROACH
            keep a curr pointer 
                only incerement if not adjaceent and currCounter < (size-1)
                increment currCounter




                






                    

        
        
                    





        

        





